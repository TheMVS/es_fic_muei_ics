---
title: "Informática como servicio"
author: "Carlos Fernandez-Lozano"
date: '`r format(Sys.Date(),"Última modificación: %e %b %Y")`'
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

# Plataforma como Servicio (PaaS)

Las plataformas como servicio o (PaaS) son un conjunto de servicios/aplicaciones basados en la nube que permite disponer de una capacidad de cálculo y almacenamiento (aparentemente) ilimitada. Obviamente el uso de dichos recursos suele tener un coste asociado y, a pesar de que el desarrollador puede centrarse en la lógica de negocio, alguien debe asumir el rol de economista y plantear límites ;)

Una de las ventajas de la virtualización y de la tecnología de contenedores es que el equipo de desarrollo puede trabajar en el mismo entorno exacto en el que se ejecutará la aplicación en producción. Es obvia la ganancia en tiempo de despliegue.

Los contenedores son una tecnología que ofrece unas ventajas similares a las máquinas virtuales pero optimizando el uso de recursos. Los contenedores tienen un tiempo de arranque reducido con respecto a una máquina convencional y además, la memoria que necesita la app ejecutada en el contenedor se ajusta sobre el proceso, en una MV se reserva la memoria completa.

**Azure** es el PaaS de Microsoft, también conocido como la nube. Permite el acceso bajo demanda a múltiples recursos computacionales: almacenamiento, servidores, aplicaciones, servicios. Realmente, Azure es SaaS, IaaS y PaaS. La gestión necesaria on-premise se aleja del usuario en tanto que el proveedor aloja el hardware y el software en su propia infraestructura y ofrece una solución integrada. En la siguiente imagen, tomada de la web de [Red Hat](https://www.redhat.com/es/topics/cloud-computing/iaas-vs-paas-vs-saas) se pueden apreciar las principales diferencias entre las `-aas` y las soluciones desplegadas en cliente. 

<img src="images/iaas-paas-saas.png" alt="Diferencias entre aas." width="90%">

De acuerdo con [Microsoft](https://azure.microsoft.com/en-us/overview/what-is-saas/) en la siguiente imagen se pueden ver las diferencias entre las `-aas` en función de los requisitos hardware y software necesarios.

<img src="images/what-is-saas.png" alt="Diferencias entre aas." width="90%">

Las tres proporcionan soluciones escalables que siguen el modelo de paga por lo que uses. La realidad es que un PaaS ofrece lo mismo que un SaaS excepto por la propia aplicación, que es el propio desarrollador el que debe mantenerla. Basicamente, a este nivel, los desarrolladores pueden desplegar y desarrollar aplicaciones sin consumo de recursos en la máquina local. Ejemplos, además de Azure pueden ser *Heroku* y *Google App Engine*.

Para comprender qué es Azure y por qué es interesante utilizarlo, vamos a plantear un ejemplo de integración con `Docker`. La idea detrás de Docker es la de utilizar contenedores portables que consumen pocos recursos para encapsular diferentes aplicaciones software que, además, puedan ejecutarse en cualquier máquina que tenga `Docker` instalado. Incluso en una nube como *Azure*. Es decir, independientemente de lo que esté corriendo por debajo en cuanto a sistema operativo o tipo de hardware de la máquina, el despliegue se llevará a cabo. Un contenedor no deja de ser algo que funciona por sí mismo, es autocontenido y que se puede llevar a cualquier parte pues funciona independientemente del soporte y es portable.

`Docker` necesita que dentro del contenedor esté todo aquello que la aplicación va a necesitar (o al menos que le indiques dónde debe ir a buscarlo y enlazarlo). Una gran ventaja es que se encierran en el contenedor las dificultades de instalación, las dependencias y demás quebraderos de cabeza y se deben sufrir una vez! por supuesto los típicos de problemas de actualización de una librería concreta o de una dependencia en una versión concreta que se pierde desaparecen. Por si fuera poco, existe un repositorio público gratutito en la nube de las imágenes que se generan llamado [DockerHub](https://hub.docker.com/) y se fundamenta todo sobre un sistema de versionado!

Una `Docker image` es una plantilla básica de un contenedor que contiene el sistemas operativo, las librerías y la aplicación. Un contenedor se arranca a partir de una imagen y, como hemos dicho, las podemos generar y descargar después desde [DockerHub](https://hub.docker.com/), que está gestionado por `Docker`.

El `Docker registry` es el servicio remoto que se utiliza para almacenar y recuperar las imágenes (con todas las versiones que se hayan subido). Se puede pagar por repositorios privados o incluso montar un repositorio propio de imágenes.

Como se ha dicho anteriormente, un `Docker container` es el equivalente a una máquina virtual y se crea a partir de una imagen. Es posible parar, pausar o parar los contenedores y las operaciones de escritura de un fichero por ejemplo, no afectan a la imagen, afectan al contenedor.

Para la gestión de los contenedores (arranque, parada, pausa, etc.) se utiliza el `Docker engine`, que permite además la gestión de las imágenes (descarga, creación, actualización, publicación, etc.). Lo más habitual es instalar el servicio en local para controlar `Docker` aunque se puede gestionar vía API REST.

Por último, el `Docker client` es un interfaz de línea de comandos (CLI) que se utiliza para controlar el `Docker engine`.

## Configuración del entorno

A continuación se mostrarán un conjunto mínimo de pasos necesarios para configurar `Docker` y ser capaces de descargar imágenes ya creadas o generar las nuestras propias a partir de un Dockerfile y subirlas al repositorio. Se muestra sobre una máquina con Ubuntu 18.04 pero sería equivalente en máquinas con otros SO instalados sobre los que pueda correr Docker, más información en los enlaces de la sección siguiente.

## Pasos previos

1. Cread una cuenta en dockerhub. [enlace](https://hub.docker.com/signup).

2. Instalad (cada uno que decida el SO que va a utilizar) el motor docker en vuestras máquinas [enlace](https://docs.docker.com/install/)

3. Vamos a desplegar la primera aplicación *dockerizada* siguiendo los siguientes pasos

Se clona una aplicación desde GitHub (se podrían descargar desde el propio DockerHub)

```{bash eval=F}
cfernandez:~>mkdir ics-master
cfernandez :~>cd ics-master
cfernandez :~/ics-master> git clone -b v1 https://github.com/docker-training/node-bulletin-board
Cloning into 'node-bulletin-board'...
remote: Enumerating objects: 190, done.
remote: Total 190 (delta 0), reused 0 (delta 0), pack-reused 190
Receiving objects: 100% (190/190), 194.43 KiB | 1.28 MiB/s, done.
Resolving deltas: 100% (82/82), done.
cfernandez:~/ics-master/>cd node-bulletin-board/bulletin-board-app
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app/>ls
app.js   Dockerfile  index.html  package.json  server.js
backend  fonts       LICENSE     readme.md     site.css
```

Mostrad el contenido del fichero *Dockerfile*

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app> cat Dockerfile 
FROM node:6.11.5

WORKDIR /usr/src/app
COPY package.json .
RUN npm install
COPY . .

CMD [ "npm", "start" ]

```

el contenido del fichero `package.json` es el siguiente:

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>cat package.json 
{
  "name": "vue-event-bulletin",
  "version": "1.0.0",
  "description": "Demo application for the scotch.io tutorial",
  "main": "server.js",
  "author": "Ryan Chenkie, Jason Lam",
  "license": "MIT",
  "dependencies": {
    "bootstrap": "^3.3.6",
    "ejs": "^2.3.4",
    "express": "^4.13.3",
    "morgan": "^1.6.1",
    "vue": "^1.0.10",
    "vue-resource": "^0.1.17"
  },
  "devDependencies": {
    "body-parser": "^1.14.1",
    "errorhandler": "^1.4.2",
    "method-override": "^2.3.5",
    "morgan": "^1.6.1"
  }
}

```

Se trata de una aplicación DEMO con licencia MIT. Se explicarán más adelante las instrucciones del `Dockerfile` (palabras clave en mayúsculas).

Un *Dockerfile* es un fichero de texto donde se indican los diferentes comandos que se quieren ejecutar sobre una imagen base de partida. Es el punto de partida que leerá el comando `$ docker build` para poder construir la imagen a partir de las instrucciones y la información de entorno que encuentre en el fichero.

Más adelante se verán buenas prácticas a la hora de crear un Dockerfile.

En el ejemplo anterior se parte de una imagen de Node.js en su versión 6.11.5 disponible en `DockerHub`

## Construye y prueba tu primera imagen Docker

### Verifica que el demonio de docker está corriendo en el sistema

```{bash eval=F}
cfernandez:~> sudo systemctl status docker
[sudo] password for cfernandez: 
docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: e
   Active: active (running) since Mon 2019-11-04 11:38:16 CET; 56min ago
     Docs: https://docs.docker.com
 Main PID: 29858 (dockerd)
    Tasks: 16
   CGroup: /system.slice/docker.service
           └─29858 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/contai

nov 04 11:38:16 xps-13-9360 dockerd[29858]: time="2019-11-04T11:38:16.259692397+
nov 04 11:38:16 xps-13-9360 systemd[1]: Started Docker Application Container Eng
nov 04 11:38:16 xps-13-9360 dockerd[29858]: time="2019-11-04T11:38:16.329498966+
nov 04 11:42:48 xps-13-9360 dockerd[29858]: time="2019-11-04T11:42:48.647115178+
nov 04 11:42:48 xps-13-9360 dockerd[29858]: time="2019-11-04T11:42:48.797315839+
nov 04 12:12:12 xps-13-9360 dockerd[29858]: time="2019-11-04T12:12:12.683677771+
nov 04 12:12:12 xps-13-9360 dockerd[29858]: time="2019-11-04T12:12:12.878200640+
nov 04 12:12:14 xps-13-9360 dockerd[29858]: time="2019-11-04T12:12:14.061923062+
nov 04 12:21:43 xps-13-9360 dockerd[29858]: time="2019-11-04T12:21:43.555673900+
nov 04 12:21:43 xps-13-9360 dockerd[29858]: time="2019-11-04T12:21:43.758197196+
```

### Generación de la imagen

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker image build -t bulletinboard:1.0 .
[sudo] password for cfernandez: 
Sending build context to Docker daemon  45.57kB
Step 1/6 : FROM node:6.11.5
6.11.5: Pulling from library/node
85b1f47fba49: Pull complete 
ba6bd283713a: Pull complete 
817c8cd48a09: Pull complete 
47cc0ed96dc3: Pull complete 
8888adcbd08b: Pull complete 
6f2de60646b9: Pull complete 
1666693bf996: Pull complete 
2fe410df7942: Pull complete 
Digest: sha256:fe109b92edafd9821fbc1c80fd7587a1b4e1ff76fec3af675869e23e50bbf45b
Status: Downloaded newer image for node:6.11.5
 ---> 852391892b9f
Step 2/6 : WORKDIR /usr/src/app
 ---> Running in e6231cc7fd75
Removing intermediate container e6231cc7fd75
 ---> 5545981ede36
Step 3/6 : COPY package.json .
 ---> 5b4753141cde
Step 4/6 : RUN npm install
 ---> Running in b97ada7582d6
vue-event-bulletin@1.0.0 /usr/src/app
+-- body-parser@1.19.0 
| +-- bytes@3.1.0 
| +-- content-type@1.0.4 
| +-- debug@2.6.9 
| | `-- ms@2.0.0 
| +-- depd@1.1.2 
| +-- http-errors@1.7.2 
| | +-- inherits@2.0.3 
| | `-- toidentifier@1.0.0 
| +-- iconv-lite@0.4.24 
| | `-- safer-buffer@2.1.2 
| +-- on-finished@2.3.0 
| | `-- ee-first@1.1.1 
| +-- qs@6.7.0 
| +-- raw-body@2.4.0 
| | `-- unpipe@1.0.0 
| `-- type-is@1.6.18 
|   +-- media-typer@0.3.0 
|   `-- mime-types@2.1.24 
|     `-- mime-db@1.40.0 
+-- bootstrap@3.4.1 
+-- ejs@2.7.1 
+-- errorhandler@1.5.1 
| +-- accepts@1.3.7 
| | `-- negotiator@0.6.2 
| `-- escape-html@1.0.3 
+-- express@4.17.1 
| +-- array-flatten@1.1.1 
| +-- content-disposition@0.5.3 
| +-- cookie@0.4.0 
| +-- cookie-signature@1.0.6 
| +-- encodeurl@1.0.2 
| +-- etag@1.8.1 
| +-- finalhandler@1.1.2 
| +-- fresh@0.5.2 
| +-- merge-descriptors@1.0.1 
| +-- methods@1.1.2 
| +-- parseurl@1.3.3 
| +-- path-to-regexp@0.1.7 
| +-- proxy-addr@2.0.5 
| | +-- forwarded@0.1.2 
| | `-- ipaddr.js@1.9.0 
| +-- range-parser@1.2.1 
| +-- safe-buffer@5.1.2 
| +-- send@0.17.1 
| | +-- destroy@1.0.4 
| | +-- mime@1.6.0 
| | `-- ms@2.1.1 
| +-- serve-static@1.14.1 
| +-- setprototypeof@1.1.1 
| +-- statuses@1.5.0 
| +-- utils-merge@1.0.1 
| `-- vary@1.1.2 
+-- method-override@2.3.10 
+-- morgan@1.9.1 
| +-- basic-auth@2.0.1 
| `-- on-headers@1.0.2 
+-- vue@1.0.28 
| `-- envify@3.4.1 
|   +-- jstransform@11.0.3 
|   | +-- base62@1.2.8 
|   | +-- commoner@0.10.8 
|   | | +-- commander@2.20.3 
|   | | +-- detective@4.7.1 
|   | | | +-- acorn@5.7.3 
|   | | | `-- defined@1.0.0 
|   | | +-- glob@5.0.15 
|   | | | +-- inflight@1.0.6 
|   | | | | `-- wrappy@1.0.2 
|   | | | +-- minimatch@3.0.4 
|   | | | | `-- brace-expansion@1.1.11 
|   | | | |   +-- balanced-match@1.0.0 
|   | | | |   `-- concat-map@0.0.1 
|   | | | +-- once@1.4.0 
|   | | | `-- path-is-absolute@1.0.1 
|   | | +-- graceful-fs@4.2.3 
|   | | +-- mkdirp@0.5.1 
|   | | | `-- minimist@0.0.8 
|   | | +-- private@0.1.8 
|   | | +-- q@1.5.1 
|   | | `-- recast@0.11.23 
|   | |   +-- ast-types@0.9.6 
|   | |   +-- esprima@3.1.3 
|   | |   `-- source-map@0.5.7 
|   | +-- esprima-fb@15001.1.0-dev-harmony-fb 
|   | +-- object-assign@2.1.1 
|   | `-- source-map@0.4.4 
|   |   `-- amdefine@1.0.1 
|   `-- through@2.3.8 
`-- vue-resource@0.1.17 

npm WARN vue-event-bulletin@1.0.0 No repository field.
Removing intermediate container b97ada7582d6
 ---> ddf9c0a82711
Step 5/6 : COPY . .
 ---> 0756607407a1
Step 6/6 : CMD [ "npm", "start" ]
 ---> Running in e3e26d80b9d0
Removing intermediate container e3e26d80b9d0
 ---> 2cfc10259620
Successfully built 2cfc10259620
Successfully tagged bulletinboard:1.0

```

### Inicializa el contenedor con la nueva imagen

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker container run --publish 8000:8080 --detach --name bb bulletinboard:1.0
e70e42aadc1b851d610bbcc79f928516ab9b5a6755b5dc54d459c993db2356a4

```

Identifica para qué se utiliza cada uno de los flags del comando.

Abre un navegador web con la siguiente dirección [localhost:8000](localhost:8000)

### Lista los contenedores Docker corriendo en el sistema y elimina el que acabas de crear

Listar contenedores activos:

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
e70e42aadc1b        bulletinboard:1.0   "npm start"         3 minutes ago       Up 3 minutes        0.0.0.0:8000->8080/tcp   bb

```

Eliminar contenedor activo:

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker container rm --force bb
bb

```

### Lista las imágenes de aplicaciones generadas

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
bulletinboard       1.0                 2cfc10259620        10 minutes ago      681MB
hello-world         latest              fce289e99eb9        10 months ago       1.84kB
node                6.11.5              852391892b9f        24 months ago       662MB
```

elimina las imágenes del sistema:

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker rmi 2cfc10259620
Untagged: bulletinboard:1.0
Deleted: sha256:2cfc1025962090cd26fe03f9b6e1effe6deea48dcba59239dbbc80bcec5e7864
Deleted: sha256:0756607407a1155bcb0a4cb4d096ccbec4cc94b5b3f73d744c63c05a777a65c4
Deleted: sha256:8f61dffcd6c523aa46e0280f45d426ff5c037078eb72c0e0da308ec231fd08fc
Deleted: sha256:ddf9c0a827117a77d02316a41869de8eb98fd57d904d0de3d6dbecba0e30dbf2
Deleted: sha256:e45dc1a3fb220748ddebd5d9b045a5e35316f97d538703469b7fb85bca93da5d
Deleted: sha256:5b4753141cdeeb33968b92dd57b6be391718b7197b82c95d730e0a569ac211e6
Deleted: sha256:f07db67280626ab53828324c6631e733ec7d12e537aeacb415734b3c03b546ff
Deleted: sha256:5545981ede3653c3c8cb07a67d279fe40d9d290ab588798d58343ef12164edaa
Deleted: sha256:bb9d9d04eaa98ca064f89f1da2ba23edd8cfacf634d5d999e513b02d60a2cc62

```

es posible que para alguna imagen sea necesario forzar la eliminación de la imagen.

```{bash eval=F}
cfernandez:~/ics-master/node-bulletin-board/bulletin-board-app>sudo docker rmi -f fce289e99eb9
Untagged: hello-world:latest
Untagged: hello-world@sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f
Deleted: sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e
```

### Realiza una búsqueda de las imágenes disponibles en Dockerhub por línea de comandos

Por ejemplo para el sistema operativo Centos.

```{bash eval=F}
cfernandez :~>sudo docker search centos
NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
centos                             The official build of CentOS.                   5648                [OK]                
ansible/centos7-ansible            Ansible on Centos7                              125                                     [OK]
jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   114                                     [OK]
consol/centos-xfce-vnc             Centos container with "headless" VNC session…   100                                     [OK]
centos/mysql-57-centos7            MySQL 5.7 SQL database server                   64                                      
imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              57                                      [OK]
tutum/centos                       Simple CentOS docker image with SSH access      44                                      
centos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   39                                      
kinogmt/centos-ssh                 CentOS with SSH                                 29                                      [OK]
pivotaldata/centos-gpdb-dev        CentOS image for GPDB development. Tag names…   10                                      
nathonfowlie/centos-jre            Latest CentOS image with the JRE pre-install…   8                                       [OK]
drecom/centos-ruby                 centos ruby                                     6                                       [OK]
centos/tools                       Docker image that has systems administration…   4                                       [OK]
darksheer/centos                   Base Centos Image -- Updated hourly             3                                       [OK]
mamohr/centos-java                 Oracle Java 8 Docker image based on Centos 7    3                                       [OK]
pivotaldata/centos                 Base centos, freshened up a little with a Do…   3                                       
pivotaldata/centos-mingw           Using the mingw toolchain to cross-compile t…   2                                       
miko2u/centos6                     CentOS6 日本語環境                                   2                                       [OK]
pivotaldata/centos-gcc-toolchain   CentOS with a toolchain, but unaffiliated wi…   2                                       
mcnaughton/centos-base             centos base image                               1                                       [OK]
indigo/centos-maven                Vanilla CentOS 7 with Oracle Java Developmen…   1                                       [OK]
blacklabelops/centos               CentOS Base Image! Built and Updates Daily!     1                                       [OK]
pivotaldata/centos6.8-dev          CentosOS 6.8 image for GPDB development         0                                       
pivotaldata/centos7-dev            CentosOS 7 image for GPDB development           0                                       
smartentry/centos                  centos with smartentry                          0                                       [OK]
```
### Descarga la imagen

Revisa el significado de cada columna mostrada por el comando anterior y descarga la imagen que consideres oportuna.

```{bash eval=F}
cfernandez:~>sudo docker image pull kinogmt/centos-ssh
Using default tag: latest
latest: Pulling from kinogmt/centos-ssh
Image docker.io/kinogmt/centos-ssh:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image for better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/
a3ed95caeb02: Pull complete 
3b231ed5aa2f: Pull complete 
b73faae918f1: Pull complete 
2f96ec4f912b: Pull complete 
50ad9044db90: Pull complete 
ba40dad95ca2: Pull complete 
1d7a70b1b1da: Pull complete 
365930eae884: Pull complete 
7568f1af3835: Pull complete 
Digest: sha256:acdf7798259f859a8e713f2f88511eef5e0f94cb2d2dec078a1fe169a8aacf63
Status: Downloaded newer image for kinogmt/centos-ssh:latest
docker.io/kinogmt/centos-ssh:latest
```
### Interacciona con la línea de comandos de la máquina Dockerizada
```{bash eval=F}
cfernandez:~>sudo docker container run -it kinogmt/centos-ssh /bin/bash
[root@c1576d0b4968 /]# rpm -q centos-release
centos-release-6-7.el6.centos.12.3.x86_64
[root@c1576d0b4968 /]# 
```
### Lista de nuevo las imágenes que tiene descargadas el sistema

```{bash eval=F}
cfernandez:~/dics-master>sudo docker image ls
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
kinogmt/centos-ssh   latest              dc8713dad282        3 years ago         773MB

```

### Lista contenedores activos e inactivos y eliminálos

```{bash eval=F}
cfernandez:~/ics-master>sudo docker container ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
cfernandez:~/ics-master>sudo docker container ls -a
CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS                      PORTS               NAMES
c1576d0b4968        kinogmt/centos-ssh   "/bin/bash"         9 minutes ago       Exited (0) 8 minutes ago                        hungry_ptolemy
83a2fea9e1b0        kinogmt/centos-ssh   "/bin/bash"         12 minutes ago      Exited (0) 9 minutes ago                        nervous_lederberg
c965a44e0e12        kinogmt/centos-ssh   "/bin/bash"         12 minutes ago      Exited (0) 12 minutes ago                       relaxed_sinoussi
cc66c4be321a        fce289e99eb9         "/hello"            8 hours ago         Exited (0) 8 hours ago                          nostalgic_goldberg

```

eliminar contenedores:

```{bash eval=F}
cfernandez:~/ics-master>sudo docker container rm c1576d0b4968 83a2fea9e1b0 c965a44e0e12 cc66c4be321a
c1576d0b4968
83a2fea9e1b0
c965a44e0e12
cc66c4be321a

```

eliminar imágenes:

```{bash eval=F}
cfernandez:~/ics-master>sudo docker rmi dc8713dad282
Untagged: kinogmt/centos-ssh:latest
Untagged: kinogmt/centos-ssh@sha256:acdf7798259f859a8e713f2f88511eef5e0f94cb2d2dec078a1fe169a8aacf63
Deleted: sha256:dc8713dad28219f7be85c1c7ab08fa858905d7b4f78bf4999e6cdcd36eae2377
Deleted: sha256:69fb5656f4ed0a7f021546ca7c5cf987110637407586f9fc45f9481b7aebf3ca
Deleted: sha256:4ef8c7ab69e2bac9031001c70dba7277dc7e9eadfe8b65cc1750b38ce3012a2b
Deleted: sha256:9389efd80ed7a3c1130602aa8c0fce06be78b8b13f2436352483ec12c2d33fc3
Deleted: sha256:69ed47c0046587473fb1520501cca07705cd4b1430e971d9f438dcdbacb68fa7
Deleted: sha256:44b4bda5288bf8d457950036db43fa4f0ee21d1393fedf6f825e93ddfa0b495c
Deleted: sha256:4df98bae5546cf893a372f58a140651a241e0bcd1af28111b0b2dc4eb91021a9
Deleted: sha256:7da59528e567882bf7d6bdf53f8ce1ed207fa1512f0ed1f6d245bd097fcbf260
Deleted: sha256:dad13f415d8417662f6a8c0790109106e05601d65651b7a8b4470fb434a83f97
Deleted: sha256:b5471e6ec524d0911384bddc342965d98f164844889e06db5f4976e56e74dbd1
Deleted: sha256:e7973ae3b5b17bb7d5a2acb9a90f52751df60e1ccdf2b85ca90b8640650684f9
Deleted: sha256:0856b2ee9c1a321ee71f5c19cb07aa0a07e11c28fa8f22d867d02a3c79080e36
Deleted: sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef

```

## Dockerfile
Alguna de las buenas prácticas que se considera a la hora de crear un fichero Dockerfile serían las siguientes:

* Debe mantenerse la configuración mínima necesaria en los contenedores, en otro caso puede que la creación, despliegue y parada de contenedores lleve un tiempo elevado de forma innecesaria.
* No instalar paquetes o dependencias innecesarios, dedicar un tiempo a estudiar los requisitos técnicos de la imagen que se va a generar.
* El funcionamiento del Dockerfile está jerarquizado en capas, debe buscarse siempre un equilibrio entre número de capas y legibilidad así como relación entre elementos de cada capa
* Utilizar de forma adecuada la `/` para organizar argumentos en múltiples líneas y permitir que el fichero sea lo más legible posible, por ejemplo para la instalación de librerías de uso general:

```{bash eval=F}
# Sección de instalación de ibrerias de uso general
RUN apt-get update && apt-get install -y --no-install-recommends \
	sudo \
	libcurl4-gnutls-dev \
	libcairo2-dev \
	libxt-dev \
	libssl-dev \
	libssh2-1-dev \
&& rm -rf /var/lib/apt/lists/*

```

### Instrucciones dentro de un Dockerfile

Para obtener una información más detalle se recomienda visitar el siguiente [enlace](https://docs.docker.com/engine/reference/builder/) con la documentación oficial. Se mostrarán las instrucciones más habituales aunque existen otras.

#### FROM

Indica la imagen de partida a partir de la cual se comenzará a crear la imagen. Lo primero que hará el motor de docker es ver si la imagen está en local, en caso contrario irá al repositorio de internet, como por ejemplo `dockerhub` y la descargará. Toda imagen debe tener un `nombre` y un `tag`, esto es una de las cosas que hace que Docker sea una herramienta de tanta utilidad, siempre será posible acceder a la máquina concreta, en su versión precisa para replicar un comportamiento.

Sintaxis:

```{bash eval=F}
FROM <nombre.imagen>
FROM <nombre.imagen>:<tag>
```

#### WORKDIR

La instrucción `WORKDIR` fija el directorio de trabajo de cualquier instrucción `RUN`, `CMD`, `ENTRYPOINT`, `COPY` o `ADD` que vayan a continuación de ella en el fichero `Dockerfile`. Se puede utilizar múltiples veces y si se trata de paths relativos, lo serán al primer `WORKDIR` del fichero. Además, se puede usar de forma conjunta con variables de entorno definidas con `ENV`. Si el directorio no existiese, se crearía.

La sintaxis sería la siguiente:

```{bash eval=F}
ENV DIRPATH=/path
WORKDIR $DIRPATH/nombreDirectorio
```



#### RUN

Es posible lanzar la ejecución de un comando sobre la capa anterior de tal forma que al finalizar se haga un commit y se genere una nueva capa. Este funcionamiento permite que, por ejemplo, si en nuestra generación de imagen con 5 capas previa se detecta un fallo o una librería que falta, cuando se construya la imagen de nuevo `docker` verifique los cambios y ejecute únicamente aquellas capas que hayan cambiado. Esto supone un ahorro en tiempo considerable. La instrucción `RUN` puede llevarse a cabo de dos formas: modo consola o modo ejecución.

**Modo consola**

La sintaxis sería como sigue:

```{bash eval=F}
RUN comando
```

**Modo ejecución**

La sintaxis sería como sigue:

```{bash eval=F}
RUN ["comando", "parámetro", "parámetro"]
```

#### ENV

Se utiliza la instrucción `ENV` para configurar aquellas variables de entorno que se desee que estén disponibles para toda la secuencia de instrucciones del fichero.

La sintaxis sería como sigue:

```{bash eval=F}
ENV <key> <value>
ENV <key>=<value>
```

#### ADD y COPY

Es posible copiar archivos o incluso directorios desde nuestra máquina al contenedor para tenerlos disponibles en la ruta especificada y que puedan ser utilizados por la imagen. Ambas instrucciones funcionan de manera similar aunque de forma general se prefiere COPY porque es más transparente que ADD. `COPY` funciona de manera intuitiva copiando ficheros del sistema local al contenedor mientras que `ADD` puede también trabajar sobre ficheros comprimidos o URLs.

La sintaxis sería como sigue:

```{bash eval=F}
COPY <origen> <destino>
```

#### EXPOSE

La instrucción `EXPOSE` indica los puertos en los que el contenedor va a escuchar a la espera de conexiones entrantes. Lo más habitual es utilizar el mismo puerto que la aplicación original utilizaría al ser desplegada en un equipo de forma convencional, por ejemplo servidores web en el 80, aunque es posible indicar el puerto sin dicha restricción.

La sintaxis sería como sigue:

```{bash eval=F}
EXPOSE 22
```

#### CMD y ENTRYPOINT

Ambas instrucciones permiten indicar qué ejecutable debe ser ejecutado cuando se inicia un contenedor. Algunas de las instrucciones anteriores pueden ponerse en el `Dockerfile` o de forma explícita en el comando `$ docker run`. En caso de no haberlo hecho así, la única manera de conseguir que la imagen sea ejecutable es con CMD o ENTRYPOINT.

Por ejemplo, las imágenes de ubuntu finalizan con `CMD ["/bin/bash"]` como se puede ver en el siguiente [enlace](https://github.com/tianon/docker-brew-ubuntu-core/blob/dist-amd64/xenial/Dockerfile).

Solamente puede existir una instrucción `CMD` en el Dockerfile, en caso de que existan más solamente la última será tenida en cuenta. El usuario podría interactuar con la imagen y el comando una vez comience a ejecutarse la máquina. En el caso de `ENTRYPOINT` el usuario no puede indicar otro comando cuando arranque le contenedor. Es decir, no se permite que el usuario ejecute otro comando que el esperado. 

Sin embargo, el uso de las instrucciones `CMD` y `ENTRYPOINT` o incluso, la combinación de ambas supera éste curso por lo que para una lectura más completa se recomienda seguir el siguiente [enlace](https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/).

La sintaxis base para ambas instrucciones sería:

```{bash eval=F}
CMD ["ejecutable", "parametro"]
ENTRYPOINT ["ejecutable", "parametro"]
```

También tiene formato ejecución y modo consola.

#### VOLUME

En caso de querer exponer algún almacenamiento, ya sea un área de almacenamiento de bases de datos, una estructura de ficheros o una configuración de almacenamiento debe usarse la instrucción `VOLUME`. Para más información acerca de como compartir volúmenes usando la consola se puede consultar el siguiente [enlace](https://docs.docker.com/storage/volumes/).

La sintaxis sería la siguiente:

```{bash eval=F}
VOLUME ["/path/files", "/path/files"]
```

# Referencias

https://linuxize.com/post/how-to-install-and-use-docker-on-ubuntu-18-04/

https://azure.microsoft.com/en-us/services/kubernetes-service/docker/

https://docs.docker.com/get-started/part2/

https://www.docker.com/get-started

https://linuxize.com/post/how-to-build-docker-images-with-dockerfile/

https://www.josedomingo.org/pledin/2016/02/dockerfile-creacion-de-imagenes-docker/